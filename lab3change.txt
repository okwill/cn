--- examples/tutorial/third.cc	2021-10-02 01:56:47.000000000 +0530
+++ scratch/lab3.cc	2021-11-21 17:23:31.727266061 +0530
@@ -1,19 +1,3 @@
-/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
-/*
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation;
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
 #include "ns3/core-module.h"
 #include "ns3/point-to-point-module.h"
 #include "ns3/network-module.h"
@@ -24,6 +8,8 @@
 #include "ns3/yans-wifi-helper.h"
 #include "ns3/ssid.h"
 
+#include "ns3/flow-monitor-module.h" //from traffic control
+
 // Default Network Topology
 //
 //   Wifi 10.1.3.0
@@ -34,42 +20,23 @@
 //                   point-to-point  |    |    |    |
 //                                   ================
 //                                     LAN 10.1.2.0
-
+// I recommend leaving this here so you don't have to remember the connections
 using namespace ns3;
 
 NS_LOG_COMPONENT_DEFINE ("ThirdScriptExample");
 
-int 
-main (int argc, char *argv[])
-{
-  bool verbose = true;
+int main (){
   uint32_t nCsma = 3;
   uint32_t nWifi = 3;
-  bool tracing = false;
+  double simulationTime = 10; //seconds
+  std::string socketType = "ns3::UdpSocketFactory";
 
-  CommandLine cmd (__FILE__);
-  cmd.AddValue ("nCsma", "Number of \"extra\" CSMA nodes/devices", nCsma);
-  cmd.AddValue ("nWifi", "Number of wifi STA devices", nWifi);
-  cmd.AddValue ("verbose", "Tell echo applications to log if true", verbose);
-  cmd.AddValue ("tracing", "Enable pcap tracing", tracing);
-
-  cmd.Parse (argc,argv);
-
-  // The underlying restriction of 18 is due to the grid position
-  // allocator's configuration; the grid layout will exceed the
-  // bounding box if more than 18 nodes are provided.
-  if (nWifi > 18)
+  if (nWifi > 250 || nCsma > 250)
     {
-      std::cout << "nWifi should be 18 or less; otherwise grid layout exceeds the bounding box" << std::endl;
+      std::cout << "nWifi and nCsma should be 250 or less; otherwise grid layout exceeds the bounding box" << std::endl;
       return 1;
     }
-
-  if (verbose)
-    {
-      LogComponentEnable ("UdpEchoClientApplication", LOG_LEVEL_INFO);
-      LogComponentEnable ("UdpEchoServerApplication", LOG_LEVEL_INFO);
-    }
-
+    
   NodeContainer p2pNodes;
   p2pNodes.Create (2);
 
@@ -98,7 +65,7 @@
   YansWifiChannelHelper channel = YansWifiChannelHelper::Default ();
   YansWifiPhyHelper phy;
   phy.SetChannel (channel.Create ());
-
+	
   WifiHelper wifi;
   wifi.SetRemoteStationManager ("ns3::AarfWifiManager");
 
@@ -153,35 +120,54 @@
   address.Assign (staDevices);
   address.Assign (apDevices);
 
-  UdpEchoServerHelper echoServer (9);
+ 
+  Ipv4GlobalRoutingHelper::PopulateRoutingTables ();
 
-  ApplicationContainer serverApps = echoServer.Install (csmaNodes.Get (nCsma));
-  serverApps.Start (Seconds (1.0));
-  serverApps.Stop (Seconds (10.0));
-
-  UdpEchoClientHelper echoClient (csmaInterfaces.GetAddress (nCsma), 9);
-  echoClient.SetAttribute ("MaxPackets", UintegerValue (1));
-  echoClient.SetAttribute ("Interval", TimeValue (Seconds (1.0)));
-  echoClient.SetAttribute ("PacketSize", UintegerValue (1024));
-
-  ApplicationContainer clientApps = 
-    echoClient.Install (wifiStaNodes.Get (nWifi - 1));
-  clientApps.Start (Seconds (2.0));
-  clientApps.Stop (Seconds (10.0));
+  //Flow
+  uint16_t port = 7;
+  Address localAddress (InetSocketAddress (Ipv4Address::GetAny (), port));
+  PacketSinkHelper packetSinkHelper (socketType, localAddress);
+  ApplicationContainer sinkApp = packetSinkHelper.Install (csmaNodes.Get (nCsma));
+
+  sinkApp.Start (Seconds (0.0));
+  sinkApp.Stop (Seconds (simulationTime + 0.1));
+
+  uint32_t payloadSize = 1448;
+  Config::SetDefault ("ns3::TcpSocket::SegmentSize", UintegerValue (payloadSize));
+
+  OnOffHelper onoff (socketType, Ipv4Address::GetAny ());
+  onoff.SetAttribute ("OnTime",  StringValue ("ns3::ConstantRandomVariable[Constant=1]"));
+  onoff.SetAttribute ("OffTime", StringValue ("ns3::ConstantRandomVariable[Constant=0]"));
+  onoff.SetAttribute ("DataRate", StringValue ("50Mbps")); //bit/s
+  ApplicationContainer apps;
+
+  InetSocketAddress rmt (csmaInterfaces.GetAddress (nCsma), port);
+  AddressValue remoteAddress (rmt);
+  onoff.SetAttribute ("Remote", remoteAddress);
+  apps.Add (onoff.Install (wifiStaNodes.Get (nWifi - 1)));
+  apps.Start (Seconds (1.0));
+  apps.Stop (Seconds (simulationTime + 0.1));
 
-  Ipv4GlobalRoutingHelper::PopulateRoutingTables ();
+  FlowMonitorHelper flowmon;
+  Ptr<FlowMonitor> monitor = flowmon.InstallAll();
 
   Simulator::Stop (Seconds (10.0));
+  Simulator::Run ();
 
-  if (tracing)
-    {
-      phy.SetPcapDataLinkType (WifiPhyHelper::DLT_IEEE802_11_RADIO);
-      pointToPoint.EnablePcapAll ("third");
-      phy.EnablePcap ("third", apDevices.Get (0));
-      csma.EnablePcap ("third", csmaDevices.Get (0), true);
-    }
+  Ptr<Ipv4FlowClassifier> classifier = DynamicCast<Ipv4FlowClassifier> (flowmon.GetClassifier ());
+  std::map<FlowId, FlowMonitor::FlowStats> stats = monitor->GetFlowStats ();
+  std::cout << std::endl << "*** Flow monitor statistics ***" << std::endl;
+  for(auto it = stats.begin(); it!=stats.end(); it++){
+	  Ipv4FlowClassifier::FiveTuple	t = classifier->FindFlow(it->first);
+	  std::cout<<"Flow ID: "<<it->first<<"\n";
+	  std::cout<<"Source address: "<<t.sourceAddress<<"\n";
+	  std::cout<<"Destination address: "<<t.destinationAddress<<"\n";
+	  std::cout<<"Tx Packets: "<<it->second.txPackets<<"\n";
+	  std::cout<<"Rx Packets: "<<it->second.rxPackets<<"\n";
+	  std::cout<<"Lost Packets: "<<it->second.lostPackets<<"\n";
+	  std::cout <<"Throughput: " <<it->second.rxBytes * 8.0 / (it->second.timeLastRxPacket.GetSeconds () - it->second.timeFirstRxPacket.GetSeconds ()) / 1000000 << " Mbps" << std::endl;
+  }
 
-  Simulator::Run ();
   Simulator::Destroy ();
   return 0;
 }
